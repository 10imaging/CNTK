# Fast-RCNN configuration for CNTK
# For algorithm and details see http://arxiv.org/abs/1504.08083
# Overview:
# The Fast-RCNN algorithm uses a DNN that takes as inputs a set of images 
# and for each image a set of ROIs (Regions of interest). It first computes
# a convolutional feature map for the entire image using a series of
# of convolutional layers (usually from a pretrained network). Then it 
# employs ROI pooling to crop out the part of the conv feature map 
# that corresponds to an ROI and resizes it to the input size expected
# by the following layer (usually a set of pretrained fully connected layers).
# Classification error and evaluation criterion are computed for each ROI.

command = Train:Test
#command = Write

deviceId = "Auto"
precision = "float"
parallelTrain = "false"
traceLevel = 1

rootDir = "." 
dataDir = "$rootDir$/data/"
outputDir = "$rootDir$/Output"

modelPath = "$outputDir$/Fast-RCNN"
stderr = "$outputDir$/Fast-RCNN.log"

ImageH = 1000
ImageW = 1000
ImageC = 3

# TODO: use sparse
NumLabels = 21
NumRegrLabels = 84              # $NumLabels$ * 4

NumTrainROIs = 64
TrainROIDim = 256               # $NumTrainROIs$ * 4 
TrainROILabelDim = 1344         # $NumTrainROIs$ * $NumLabels$
TrainRegrDim = 84*64            # $NumTrainROIs$ * $NumRegrLabels$

NumTestROIs = 200
TestROIDim = 800
TestROILabelDim = 4200
TestRegrDim = 84*64             # $NumTestROIs$ * $NumRegrLabels$


# For training we load a pretrained AlexNet model (AlexNet.89) and clone three parts of it.
# For the first part (up to pool1) we keep the weights fixed. The middle part contains the
# remaining convolutional and pooling layers and the last part are the FC layers. 
# In the model we apply the first two cloned parts, then an ROI pooling layer and 
# finally the pretrained FC layers followed by a new FC layer that maps to the new 
# label dimensionality of 21 classes. 
# The inputs are images (1000 x 1000 x 3), ROIs (64 ROIs x 4 coordinates (x, y, w, h))
# and ground truht labels per ROI (64 ROIs x 21 classes).
Train = {
    action = "train"
    
    BrainScriptNetworkBuilder = {
        # using ndl model:
        network     = BS.Network.Load ("../../../../../PretrainedModels/AlexNet.model")
        convLayers  = BS.Network.CloneFunction(network.features, network.conv5_y, parameters = "constant")
        fcLayers    = BS.Network.CloneFunction(network.pool3, network.h2_d)
        # using brain scipt model
        #network     = BS.Network.Load ("../../../../../PretrainedModels/AlexNetBS.model")
        #convLayers  = BS.Network.CloneFunction(network.features, network.z_x___x___x_x, parameters = "constant")    # network.features, network.z.x._.x._.x.x
        #fcLayers    = BS.Network.CloneFunction(network.z_x___x___x, network.z_x)                                    # network.z.x._.x._.x, network.z.x

        model (features, rois) = {
            featNorm = features - 114
            convOut  = convLayers (featNorm)
            roiOut   = ROIPooling (conv5Out, rois, (6:6))
            fcOut    = fcLayers (roiOut)
            # Label prediction
            WPred    = ParameterTensor{(21:4096)}
            bPred    = ParameterTensor{21, init = 'zero'}
            pred     = WPred * fcOut + bPred
            # bounding box regression
            WRegr    = ParameterTensor{($RegrDim$:4096)}
            bRegr    = ParameterTensor{$RegrDim$, init = 'zero'}
            regr     = WRegr * fcOut + bRegr
        }

        imageShape = $ImageH$:$ImageW$:$ImageC$         # 1000:1000:3
        labelShape = $NumLabels$:$NumTrainROIs$         # 21:64
        ROIShape   = 4:$NumTrainROIs$                   # 4:64
        regrShape  = $NumRegrLabels$:$NumTrainROIs$     # 84:64
        
        features        = Input {imageShape}
        roiLabels       = Input {labelShape}
        rois            = Input {ROIShape}
        regrGT          = Input {regrShape}
        
        out = model (features, rois)
        
        ce = NewCrossEntropyWithSoftmax(roiLabels, out.pred, axis = 1)
        errs = ClassificationError(roiLabels, out.pred, axis = 1)
        # predLoss = LogLoss(roiLabels, out.pred, axis = 1)
        ## logLoss = -log(p_u)   , where u is the true class
        ## --> CrossEntropyWithSoftmax(roiLabels, out.pred, axis = 1)
        ### ?? is there a softmax missing in core.bs ??
        ## --> - ReduceLogSum(softmax(out.pred) .* roiLabels)
        ## (or use: MySoftmax (z) = Exp (z - ReduceLogSum (z)))
        # regrLoss = SmoothL1Loss(regrGroundTruth, out.regr, axis = 1)
        ## SmoothL1Loss = sum_{x, y, w, h} smoothL1(t_u - v)   , where t=pred and v=gt
        ## where SmoothL1 = if |x| < 1 then (.5 * x^2) else (|x| - .5)
        ## -> with x = abs((out.regr .* (regrGT > 0)) - regrGT)
        ## -> with a = x .* x .* 0.5
        ## -> with b = x - 0.5
        ## --> ReduceSum(If(Less(x, 1.0), a, b)
        # loss = predLoss + IF (argMax(roiLabels, axis=1) > 0) regrLoss ELSE 0
        
        featureNodes    = (features:rois)
        labelNodes      = (roiLabels)
        criterionNodes  = (ce)
        evaluationNodes = (errs)
        outputNodes     = (out.pred:out.regr)
    }

    SGD = {
        epochSize = 0
        minibatchSize = 2
        maxEpochs = 15
        
        learningRatesPerSample = 0.00005
        momentumAsTimeConstant = 0*5:1024 # was: 0.9 per MB 
        L2RegWeight = 0.0001
        dropoutRate = 0.5
        
        numMBsToShowResult = 50
    }

    reader = {
        randomize = false
        verbosity = 2
        deserializers = ({
            type = "CNTKTextFormatDeserializer" ; module = "CNTKTextFormatReader"
            file = "$dataDir$/tv2012pad.rois.txt"
            input = { rois = { dim = $TrainROIDim$ ; format = "dense" } }
        }:{
            type = "CNTKTextFormatDeserializer" ; module = "CNTKTextFormatReader"
            file = "$dataDir$/tv2012pad.roilabels.txt"
            input = { roiLabels = { dim = $TrainROILabelDim$ ; format = "dense" } }
        }:{
            type = "ImageDeserializer" ; module = "ImageReader"
            file = "$dataDir$/tv2012pad.txt"
            input = {
                features = { transforms = (
                    { type = "ScaleSide" ; target = $ImageW$ ; side = "max" }:
                    { type = "Pad" ; width = $ImageW$ ; height = $ImageH$; channels = $ImageC$; value = 114 }:
                    { type = "Transpose" }
                )}
                ignored = {labelDim = 1000}
            }
        })
    }
}

# For testing we load the trained Fast-RCNN model and modify the input size,
# such that the network accepts 200 ROIs per image. To this end we load and 
# clone the entire network and define new inputs with the desired size 
# corresponding to 200 ROIs. 
Test = {
    action = "test"
    minibatchSize = 1

    # use this for write action
    # action = "write"
    # outputPath = "$OutputDir$/fastrcnnNetOutput"
    
    BrainScriptNetworkBuilder = {
        imageShape = $ImageH$:$ImageW$:$ImageC$        # 1000:1000:3
        labelShape = $NumLabels$:$NumTestROIs$         # 21:200
        ROIShape   = 4:$NumTestROIs$                   # 4:200

        # load network
        network = BS.Network.Load ("$modelPath$")
        clonedNet = BS.Network.CloneFunction ((network.features:network.rois), { z = network.z }, parameters = "constant")

        features = Input {imageShape}
        roiLabels = Input {labelShape}
        rois = Input {ROIShape}

        z = clonedNet(features, rois).z
        
        ce = NewCrossEntropyWithSoftmax (roiLabels, z, axis = 1)
        errs = ClassificationError(z, roiLabels, axis = 1)
        
        featureNodes    = (features:rois)
        labelNodes      = (roiLabels)
        criterionNodes  = (ce)
        evaluationNodes = (errs)
        outputNodes     = (z)
    }
    
    reader = {
        randomize = false
        verbosity = 2
        deserializers = ({
            type = "CNTKTextFormatDeserializer" ; module = "CNTKTextFormatReader"
            file = "$dataDir$/test2007pad_all.rois.txt"
            input = { rois = { dim = $TestROIDim$ ; format = "dense" } }
        }:{
            type = "CNTKTextFormatDeserializer" ; module = "CNTKTextFormatReader"
            file = "$dataDir$/test2007pad_all.roilabels.txt"
            input = { roiLabels = { dim = $TestROILabelDim$ ; format = "dense" } }
        }:{
            type = "ImageDeserializer" ; module = "ImageReader"
            file = "$dataDir$/test2007pad_all.txt"
            input = {
                features = { transforms = (
                    { type = "ScaleSide" ; target = $ImageW$ ; side = "max" }:
                    { type = "Pad" ; width = $ImageW$ ; height = $ImageH$; channels = $ImageC$; value = 114 }:
                    { type = "Transpose" }
                )}
                ignored = {labelDim = 1000}
            }
        })
    }
}
